// *** WARNING: this file was generated by Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs, enums } from "./types";
import * as utilities from "./utilities";

import {SelfSignedCertSubject} from "./index";

/**
 * This resources helps you create a self signed certificate.
 *
 * ## Example Usage
 *
 * ### Self Signed Certificate
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as tls_self_signed_cert from "@pulumi/tls-self-signed-cert";
 *
 * const cert = new tls_self_signed_cert.SelfSignedCertificate("cert", {
 *     dnsName: "cert.example.com",
 *     validityPeriodHours: 807660,
 *     localValidityPeriodHours: 17520,
 *     subject: {
 *         commonName: "example-cert",
 *         organization: "example-cert LLC",
 *     },
 * });
 * export const pem = cert.pem;
 * export const privateKey = cert.privateKey;
 * export const caCert = cert.caCert;
 * ```
 * {{ /example }}\n{{% examples %}}
 */
export class SelfSignedCertificate extends pulumi.ComponentResource {
    /** @internal */
    public static readonly __pulumiType = 'tls-self-signed-cert:index:SelfSignedCertificate';

    /**
     * Returns true if the given object is an instance of SelfSignedCertificate.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is SelfSignedCertificate {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === SelfSignedCertificate.__pulumiType;
    }

    /**
     * Your self signed cert.
     */
    public /*out*/ readonly caCert!: pulumi.Output<string>;
    /**
     * The PEM of your self signed cert.
     */
    public /*out*/ readonly pem!: pulumi.Output<string>;
    /**
     * The private key of your self signed cert.
     */
    public /*out*/ readonly privateKey!: pulumi.Output<string>;

    /**
     * Create a SelfSignedCertificate resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: SelfSignedCertificateArgs, opts?: pulumi.ComponentResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (!opts.id) {
            if ((!args || args.localValidityPeriodHours === undefined) && !opts.urn) {
                throw new Error("Missing required property 'localValidityPeriodHours'");
            }
            if ((!args || args.subject === undefined) && !opts.urn) {
                throw new Error("Missing required property 'subject'");
            }
            if ((!args || args.validityPeriodHours === undefined) && !opts.urn) {
                throw new Error("Missing required property 'validityPeriodHours'");
            }
            resourceInputs["algorithm"] = args ? args.algorithm : undefined;
            resourceInputs["allowedUses"] = args ? args.allowedUses : undefined;
            resourceInputs["dnsName"] = args ? args.dnsName : undefined;
            resourceInputs["ecdsaCurve"] = args ? args.ecdsaCurve : undefined;
            resourceInputs["ipAddress"] = args ? args.ipAddress : undefined;
            resourceInputs["localValidityPeriodHours"] = args ? args.localValidityPeriodHours : undefined;
            resourceInputs["rsaBits"] = args ? args.rsaBits : undefined;
            resourceInputs["subject"] = args ? args.subject : undefined;
            resourceInputs["validityPeriodHours"] = args ? args.validityPeriodHours : undefined;
            resourceInputs["caCert"] = undefined /*out*/;
            resourceInputs["pem"] = undefined /*out*/;
            resourceInputs["privateKey"] = undefined /*out*/;
        } else {
            resourceInputs["caCert"] = undefined /*out*/;
            resourceInputs["pem"] = undefined /*out*/;
            resourceInputs["privateKey"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(SelfSignedCertificate.__pulumiType, name, resourceInputs, opts, true /*remote*/);
    }
}

/**
 * The set of arguments for constructing a SelfSignedCertificate resource.
 */
export interface SelfSignedCertificateArgs {
    /**
     * Name of the algorithm to use when generating the private key. Currently-supported values are `RSA`, `ECDSA` and `ED25519` (default: `RSA`).
     */
    algorithm?: pulumi.Input<enums.Algorithm>;
    /**
     * List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `any_extended`, `cert_signing`, `client_auth`, `code_signing`, `content_commitment`, `crl_signing`, `data_encipherment`, `decipher_only`, `digital_signature`, `email_protection`, `encipher_only`, `ipsec_end_system`, `ipsec_tunnel`, `ipsec_user`, `key_agreement`, `key_encipherment`, `microsoft_commercial_code_signing`, `microsoft_kernel_code_signing`, `microsoft_server_gated_crypto`, `netscape_server_gated_crypto`, `ocsp_signing`, `server_auth`, `timestamping`.
     */
    allowedUses?: pulumi.Input<pulumi.Input<enums.AllowedUses>[]>;
    /**
     * The DNS name for which a certificate is being requested (i.e. certificate subjects).
     */
    dnsName?: pulumi.Input<string>;
    /**
     * When `algorithm` is `ECDSA`, the name of the elliptic curve to use. Currently-supported values are `P224`, `P256`, `P384` or `P521` (default: `P224`).
     */
    ecdsaCurve?: pulumi.Input<enums.EcdsaCurve>;
    /**
     * The IP address for which a certificate is being requested (i.e. certificate subjects).
     */
    ipAddress?: pulumi.Input<string>;
    /**
     * Number of hours, after initial issuing, that the local certificate will remain valid for.
     */
    localValidityPeriodHours: pulumi.Input<number>;
    /**
     * When `algorithm` is `RSA`, the size of the generated RSA key, in bits (default: `2048`).
     */
    rsaBits?: pulumi.Input<number>;
    /**
     * The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.
     */
    subject: pulumi.Input<SelfSignedCertSubject>;
    /**
     * Number of hours, after initial issuing, that the certificate will remain valid for.
     */
    validityPeriodHours: pulumi.Input<number>;
}
