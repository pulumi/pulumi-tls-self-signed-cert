// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package tlsselfsignedcert

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi-tls/sdk/v4/go/tls"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resources helps you create a self signed certificate.
//
// ## Example Usage
//
// ### Self Signed Certificate
//
// ```go
// package main
//
// import (
//
//	selfSignedCert "github.com/pulumi/pulumi-tls-self-signed-cert/sdk/go/tls-self-signed-cert"
//	"github.com/pulumi/pulumi-tls/sdk/v4/go/tls"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//	    pulumi.Run(func(ctx *pulumi.Context) error {
//	        cert, err := selfSignedCert.NewSelfSignedCertificate(ctx, "cert", &selfSignedCert.SelfSignedCertificateArgs{
//	            DnsName:                  pulumi.String("cert.example.com"),
//	            ValidityPeriodHours:      pulumi.Int(807660),
//	            LocalValidityPeriodHours: pulumi.Int(17520),
//	            Subject: tls.SelfSignedCertSubjectArgs{
//	                CommonName:   pulumi.String("example-cert"),
//	                Organization: pulumi.String("example-cert LLC"),
//	            },
//	        })
//	        if err != nil {
//	            return err
//	        }
//
//	        ctx.Export("pem", cert.Pem)
//	        ctx.Export("privateKey", cert.PrivateKey)
//	        ctx.Export("caCert", cert.CaCert)
//	    })
//	}
//
// ```
// {{ /example }}\n{{% examples %}}
type SelfSignedCertificate struct {
	pulumi.ResourceState

	// Your self signed cert.
	CaCert pulumi.StringOutput `pulumi:"caCert"`
	// The PEM of your self signed cert.
	Pem pulumi.StringOutput `pulumi:"pem"`
	// The private key of your self signed cert.
	PrivateKey pulumi.StringOutput `pulumi:"privateKey"`
}

// NewSelfSignedCertificate registers a new resource with the given unique name, arguments, and options.
func NewSelfSignedCertificate(ctx *pulumi.Context,
	name string, args *SelfSignedCertificateArgs, opts ...pulumi.ResourceOption) (*SelfSignedCertificate, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LocalValidityPeriodHours == nil {
		return nil, errors.New("invalid value for required argument 'LocalValidityPeriodHours'")
	}
	if args.Subject == nil {
		return nil, errors.New("invalid value for required argument 'Subject'")
	}
	if args.ValidityPeriodHours == nil {
		return nil, errors.New("invalid value for required argument 'ValidityPeriodHours'")
	}
	var resource SelfSignedCertificate
	err := ctx.RegisterRemoteComponentResource("tls-self-signed-cert:index:SelfSignedCertificate", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type selfSignedCertificateArgs struct {
	// Name of the algorithm to use when generating the private key. Currently-supported values are `RSA`, `ECDSA` and `ED25519` (default: `RSA`).
	Algorithm *Algorithm `pulumi:"algorithm"`
	// List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `any_extended`, `cert_signing`, `client_auth`, `code_signing`, `content_commitment`, `crl_signing`, `data_encipherment`, `decipher_only`, `digital_signature`, `email_protection`, `encipher_only`, `ipsec_end_system`, `ipsec_tunnel`, `ipsec_user`, `key_agreement`, `key_encipherment`, `microsoft_commercial_code_signing`, `microsoft_kernel_code_signing`, `microsoft_server_gated_crypto`, `netscape_server_gated_crypto`, `ocsp_signing`, `server_auth`, `timestamping`.
	AllowedUses []AllowedUses `pulumi:"allowedUses"`
	// The DNS name for which a certificate is being requested (i.e. certificate subjects).
	DnsName *string `pulumi:"dnsName"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use. Currently-supported values are `P224`, `P256`, `P384` or `P521` (default: `P224`).
	EcdsaCurve *EcdsaCurve `pulumi:"ecdsaCurve"`
	// The IP address for which a certificate is being requested (i.e. certificate subjects).
	IpAddress *string `pulumi:"ipAddress"`
	// Number of hours, after initial issuing, that the local certificate will remain valid for.
	LocalValidityPeriodHours int `pulumi:"localValidityPeriodHours"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits (default: `2048`).
	RsaBits *int `pulumi:"rsaBits"`
	// The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.
	Subject SelfSignedCertSubject `pulumi:"subject"`
	// Number of hours, after initial issuing, that the certificate will remain valid for.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

// The set of arguments for constructing a SelfSignedCertificate resource.
type SelfSignedCertificateArgs struct {
	// Name of the algorithm to use when generating the private key. Currently-supported values are `RSA`, `ECDSA` and `ED25519` (default: `RSA`).
	Algorithm AlgorithmPtrInput
	// List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `any_extended`, `cert_signing`, `client_auth`, `code_signing`, `content_commitment`, `crl_signing`, `data_encipherment`, `decipher_only`, `digital_signature`, `email_protection`, `encipher_only`, `ipsec_end_system`, `ipsec_tunnel`, `ipsec_user`, `key_agreement`, `key_encipherment`, `microsoft_commercial_code_signing`, `microsoft_kernel_code_signing`, `microsoft_server_gated_crypto`, `netscape_server_gated_crypto`, `ocsp_signing`, `server_auth`, `timestamping`.
	AllowedUses AllowedUsesArrayInput
	// The DNS name for which a certificate is being requested (i.e. certificate subjects).
	DnsName pulumi.StringPtrInput
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use. Currently-supported values are `P224`, `P256`, `P384` or `P521` (default: `P224`).
	EcdsaCurve EcdsaCurvePtrInput
	// The IP address for which a certificate is being requested (i.e. certificate subjects).
	IpAddress pulumi.StringPtrInput
	// Number of hours, after initial issuing, that the local certificate will remain valid for.
	LocalValidityPeriodHours pulumi.IntInput
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits (default: `2048`).
	RsaBits pulumi.IntPtrInput
	// The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.
	Subject SelfSignedCertSubjectInput
	// Number of hours, after initial issuing, that the certificate will remain valid for.
	ValidityPeriodHours pulumi.IntInput
}

func (SelfSignedCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*selfSignedCertificateArgs)(nil)).Elem()
}

type SelfSignedCertificateInput interface {
	pulumi.Input

	ToSelfSignedCertificateOutput() SelfSignedCertificateOutput
	ToSelfSignedCertificateOutputWithContext(ctx context.Context) SelfSignedCertificateOutput
}

func (*SelfSignedCertificate) ElementType() reflect.Type {
	return reflect.TypeOf((**SelfSignedCertificate)(nil)).Elem()
}

func (i *SelfSignedCertificate) ToSelfSignedCertificateOutput() SelfSignedCertificateOutput {
	return i.ToSelfSignedCertificateOutputWithContext(context.Background())
}

func (i *SelfSignedCertificate) ToSelfSignedCertificateOutputWithContext(ctx context.Context) SelfSignedCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SelfSignedCertificateOutput)
}

// SelfSignedCertificateArrayInput is an input type that accepts SelfSignedCertificateArray and SelfSignedCertificateArrayOutput values.
// You can construct a concrete instance of `SelfSignedCertificateArrayInput` via:
//
//	SelfSignedCertificateArray{ SelfSignedCertificateArgs{...} }
type SelfSignedCertificateArrayInput interface {
	pulumi.Input

	ToSelfSignedCertificateArrayOutput() SelfSignedCertificateArrayOutput
	ToSelfSignedCertificateArrayOutputWithContext(context.Context) SelfSignedCertificateArrayOutput
}

type SelfSignedCertificateArray []SelfSignedCertificateInput

func (SelfSignedCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SelfSignedCertificate)(nil)).Elem()
}

func (i SelfSignedCertificateArray) ToSelfSignedCertificateArrayOutput() SelfSignedCertificateArrayOutput {
	return i.ToSelfSignedCertificateArrayOutputWithContext(context.Background())
}

func (i SelfSignedCertificateArray) ToSelfSignedCertificateArrayOutputWithContext(ctx context.Context) SelfSignedCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SelfSignedCertificateArrayOutput)
}

// SelfSignedCertificateMapInput is an input type that accepts SelfSignedCertificateMap and SelfSignedCertificateMapOutput values.
// You can construct a concrete instance of `SelfSignedCertificateMapInput` via:
//
//	SelfSignedCertificateMap{ "key": SelfSignedCertificateArgs{...} }
type SelfSignedCertificateMapInput interface {
	pulumi.Input

	ToSelfSignedCertificateMapOutput() SelfSignedCertificateMapOutput
	ToSelfSignedCertificateMapOutputWithContext(context.Context) SelfSignedCertificateMapOutput
}

type SelfSignedCertificateMap map[string]SelfSignedCertificateInput

func (SelfSignedCertificateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SelfSignedCertificate)(nil)).Elem()
}

func (i SelfSignedCertificateMap) ToSelfSignedCertificateMapOutput() SelfSignedCertificateMapOutput {
	return i.ToSelfSignedCertificateMapOutputWithContext(context.Background())
}

func (i SelfSignedCertificateMap) ToSelfSignedCertificateMapOutputWithContext(ctx context.Context) SelfSignedCertificateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SelfSignedCertificateMapOutput)
}

type SelfSignedCertificateOutput struct{ *pulumi.OutputState }

func (SelfSignedCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SelfSignedCertificate)(nil)).Elem()
}

func (o SelfSignedCertificateOutput) ToSelfSignedCertificateOutput() SelfSignedCertificateOutput {
	return o
}

func (o SelfSignedCertificateOutput) ToSelfSignedCertificateOutputWithContext(ctx context.Context) SelfSignedCertificateOutput {
	return o
}

type SelfSignedCertificateArrayOutput struct{ *pulumi.OutputState }

func (SelfSignedCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SelfSignedCertificate)(nil)).Elem()
}

func (o SelfSignedCertificateArrayOutput) ToSelfSignedCertificateArrayOutput() SelfSignedCertificateArrayOutput {
	return o
}

func (o SelfSignedCertificateArrayOutput) ToSelfSignedCertificateArrayOutputWithContext(ctx context.Context) SelfSignedCertificateArrayOutput {
	return o
}

func (o SelfSignedCertificateArrayOutput) Index(i pulumi.IntInput) SelfSignedCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SelfSignedCertificate {
		return vs[0].([]*SelfSignedCertificate)[vs[1].(int)]
	}).(SelfSignedCertificateOutput)
}

type SelfSignedCertificateMapOutput struct{ *pulumi.OutputState }

func (SelfSignedCertificateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SelfSignedCertificate)(nil)).Elem()
}

func (o SelfSignedCertificateMapOutput) ToSelfSignedCertificateMapOutput() SelfSignedCertificateMapOutput {
	return o
}

func (o SelfSignedCertificateMapOutput) ToSelfSignedCertificateMapOutputWithContext(ctx context.Context) SelfSignedCertificateMapOutput {
	return o
}

func (o SelfSignedCertificateMapOutput) MapIndex(k pulumi.StringInput) SelfSignedCertificateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SelfSignedCertificate {
		return vs[0].(map[string]*SelfSignedCertificate)[vs[1].(string)]
	}).(SelfSignedCertificateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SelfSignedCertificateInput)(nil)).Elem(), &SelfSignedCertificate{})
	pulumi.RegisterInputType(reflect.TypeOf((*SelfSignedCertificateArrayInput)(nil)).Elem(), SelfSignedCertificateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SelfSignedCertificateMapInput)(nil)).Elem(), SelfSignedCertificateMap{})
	pulumi.RegisterOutputType(SelfSignedCertificateOutput{})
	pulumi.RegisterOutputType(SelfSignedCertificateArrayOutput{})
	pulumi.RegisterOutputType(SelfSignedCertificateMapOutput{})
}
