// *** WARNING: this file was generated by Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.TlsSelfSignedCert
{
    /// <summary>
    /// This resources helps you create a self signed certificate.
    /// 
    /// ## Example Usage
    /// 
    /// ### Self Signed Certificate
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using Pulumi;
    /// using TlsSelfSignedCert = Pulumi.TlsSelfSignedCert;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var cert = new TlsSelfSignedCert.SelfSignedCertificate("cert", new()
    ///     {
    ///         DnsName = "cert.example.com",
    ///         ValidityPeriodHours = 807660,
    ///         LocalValidityPeriodHours = 17520,
    ///         Subject = %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),
    ///     });
    /// 
    ///     return new Dictionary&lt;string, object?&gt;
    ///     {
    ///         ["pem"] = cert.Pem,
    ///         ["privateKey"] = cert.PrivateKey,
    ///         ["caCert"] = cert.CaCert,
    ///     };
    /// });
    /// ```
    /// {{ /example }}\n{{% examples %}}
    /// </summary>
    [TlsSelfSignedCertResourceType("tls-self-signed-cert:index:SelfSignedCertificate")]
    public partial class SelfSignedCertificate : Pulumi.ComponentResource
    {
        /// <summary>
        /// Your self signed cert.
        /// </summary>
        [Output("caCert")]
        public Output<string> CaCert { get; private set; } = null!;

        /// <summary>
        /// The PEM of your self signed cert.
        /// </summary>
        [Output("pem")]
        public Output<string> Pem { get; private set; } = null!;

        /// <summary>
        /// The private key of your self signed cert.
        /// </summary>
        [Output("privateKey")]
        public Output<string> PrivateKey { get; private set; } = null!;


        /// <summary>
        /// Create a SelfSignedCertificate resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public SelfSignedCertificate(string name, SelfSignedCertificateArgs args, ComponentResourceOptions? options = null)
            : base("tls-self-signed-cert:index:SelfSignedCertificate", name, args ?? new SelfSignedCertificateArgs(), MakeResourceOptions(options, ""), remote: true)
        {
        }

        private static ComponentResourceOptions MakeResourceOptions(ComponentResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new ComponentResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = ComponentResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
    }

    public sealed class SelfSignedCertificateArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of the algorithm to use when generating the private key. Currently-supported values are `RSA`, `ECDSA` and `ED25519` (default: `RSA`).
        /// </summary>
        [Input("algorithm")]
        public Input<Pulumi.TlsSelfSignedCert.Algorithm>? Algorithm { get; set; }

        [Input("allowedUses")]
        private InputList<Pulumi.TlsSelfSignedCert.AllowedUses>? _allowedUses;

        /// <summary>
        /// List of key usages allowed for the issued certificate. Values are defined in [RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280) and combine flags defined by both [Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3) and [Extended Key Usages](https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12). Accepted values: `any_extended`, `cert_signing`, `client_auth`, `code_signing`, `content_commitment`, `crl_signing`, `data_encipherment`, `decipher_only`, `digital_signature`, `email_protection`, `encipher_only`, `ipsec_end_system`, `ipsec_tunnel`, `ipsec_user`, `key_agreement`, `key_encipherment`, `microsoft_commercial_code_signing`, `microsoft_kernel_code_signing`, `microsoft_server_gated_crypto`, `netscape_server_gated_crypto`, `ocsp_signing`, `server_auth`, `timestamping`.
        /// </summary>
        public InputList<Pulumi.TlsSelfSignedCert.AllowedUses> AllowedUses
        {
            get => _allowedUses ?? (_allowedUses = new InputList<Pulumi.TlsSelfSignedCert.AllowedUses>());
            set => _allowedUses = value;
        }

        /// <summary>
        /// The DNS name for which a certificate is being requested (i.e. certificate subjects).
        /// </summary>
        [Input("dnsName")]
        public Input<string>? DnsName { get; set; }

        /// <summary>
        /// When `algorithm` is `ECDSA`, the name of the elliptic curve to use. Currently-supported values are `P224`, `P256`, `P384` or `P521` (default: `P224`).
        /// </summary>
        [Input("ecdsaCurve")]
        public Input<Pulumi.TlsSelfSignedCert.EcdsaCurve>? EcdsaCurve { get; set; }

        /// <summary>
        /// The IP address for which a certificate is being requested (i.e. certificate subjects).
        /// </summary>
        [Input("ipAddress")]
        public Input<string>? IpAddress { get; set; }

        /// <summary>
        /// Number of hours, after initial issuing, that the local certificate will remain valid for.
        /// </summary>
        [Input("localValidityPeriodHours", required: true)]
        public Input<int> LocalValidityPeriodHours { get; set; } = null!;

        /// <summary>
        /// When `algorithm` is `RSA`, the size of the generated RSA key, in bits (default: `2048`).
        /// </summary>
        [Input("rsaBits")]
        public Input<int>? RsaBits { get; set; }

        /// <summary>
        /// The subject for which a certificate is being requested. The acceptable arguments are all optional and their naming is based upon [Issuer Distinguished Names (RFC5280)](https://tools.ietf.org/html/rfc5280#section-4.1.2.4) section.
        /// </summary>
        [Input("subject", required: true)]
        public Input<Pulumi.TlsSelfSignedCert.Inputs.SelfSignedCertSubject> Subject { get; set; } = null!;

        /// <summary>
        /// Number of hours, after initial issuing, that the certificate will remain valid for.
        /// </summary>
        [Input("validityPeriodHours", required: true)]
        public Input<int> ValidityPeriodHours { get; set; } = null!;

        public SelfSignedCertificateArgs()
        {
        }
    }
}
